{"version":3,"file":"index-L60y6kc9.js","sources":["../../node_modules/ip-bigint/dist/index.js","../../node_modules/cidr-tools/index.js"],"sourcesContent":["const max4 = 2n ** 32n - 1n;\nconst max6 = 2n ** 128n - 1n;\nfunction ipVersion(ip) {\n  return ip.includes(\":\") ? 6 : ip.includes(\".\") ? 4 : 0;\n}\nfunction parseIp(ip) {\n  const version = ipVersion(ip);\n  if (!version) throw new Error(`Invalid IP address: ${ip}`);\n  let number = 0n;\n  let exp = 0n;\n  const res = /* @__PURE__ */ Object.create(null);\n  if (version === 4) {\n    for (const n of ip.split(\".\").map(BigInt).reverse()) {\n      number += n * 2n ** exp;\n      exp += 8n;\n    }\n  } else {\n    if (ip.includes(\".\")) {\n      res.ipv4mapped = true;\n      ip = ip.split(\":\").map((part) => {\n        if (part.includes(\".\")) {\n          const [a, b, c, d] = part.split(\".\").map((str) => Number(str).toString(16).padStart(2, \"0\"));\n          return `${a}${b}:${c}${d}`;\n        } else {\n          return part;\n        }\n      }).join(\":\");\n    }\n    if (ip.includes(\"%\")) {\n      let scopeid;\n      [, ip, scopeid] = /(.+)%(.+)/.exec(ip) || [];\n      res.scopeid = scopeid;\n    }\n    const parts = ip.split(\":\");\n    const index = parts.indexOf(\"\");\n    if (index !== -1) {\n      while (parts.length < 8) {\n        parts.splice(index, 0, \"\");\n      }\n    }\n    for (const n of parts.map((part) => BigInt(parseInt(part || \"0\", 16))).reverse()) {\n      number += n * 2n ** exp;\n      exp += 16n;\n    }\n  }\n  res.number = number;\n  res.version = version;\n  return res;\n}\nfunction stringifyIp({ number, version, ipv4mapped, scopeid }, { compress = true, hexify = false } = {}) {\n  let step = version === 4 ? 24n : 112n;\n  const stepReduction = version === 4 ? 8n : 16n;\n  let remain = number;\n  const parts = [];\n  while (step > 0n) {\n    const divisor = 2n ** step;\n    parts.push(remain / divisor);\n    remain = number % divisor;\n    step -= stepReduction;\n  }\n  parts.push(remain);\n  if (version === 4) {\n    return parts.join(\".\");\n  } else {\n    let ip = \"\";\n    if (ipv4mapped && !hexify) {\n      for (const [index, num] of parts.entries()) {\n        if (index < 6) {\n          ip += `${num.toString(16)}:`;\n        } else {\n          ip += `${String(num >> 8n)}.${String(num & 255n)}${index === 6 ? \".\" : \"\"}`;\n        }\n      }\n      if (compress) {\n        ip = compressIPv6(ip.split(\":\"));\n      }\n    } else {\n      if (compress) {\n        ip = compressIPv6(parts.map((n) => n.toString(16)));\n      } else {\n        ip = parts.map((n) => n.toString(16)).join(\":\");\n      }\n    }\n    return scopeid ? `${ip}%${scopeid}` : ip;\n  }\n}\nfunction normalizeIp(ip, { compress = true, hexify = false } = {}) {\n  return stringifyIp(parseIp(ip), { compress, hexify });\n}\nfunction compressIPv6(parts) {\n  let longest = null;\n  let current = null;\n  for (const [index, part] of parts.entries()) {\n    if (part === \"0\") {\n      if (!current) {\n        current = /* @__PURE__ */ new Set([index]);\n      } else {\n        current.add(index);\n      }\n    } else {\n      if (current) {\n        if (!longest || current.size > longest.size) {\n          longest = current;\n        }\n        current = null;\n      }\n    }\n  }\n  if (!longest && current || current && longest && current.size > longest.size) {\n    longest = current;\n  }\n  for (const index of longest || []) {\n    parts[index] = \":\";\n  }\n  return parts.filter(Boolean).join(\":\").replace(/:{2,}/, \"::\");\n}\nexport {\n  ipVersion,\n  max4,\n  max6,\n  normalizeIp,\n  parseIp,\n  stringifyIp\n};\n","import {parseIp, stringifyIp, normalizeIp, ipVersion} from \"ip-bigint\";\n\nconst bits = {4: 32, 6: 128};\nconst uniq = arr => Array.from(new Set(arr));\nconst cidrVersion = cidr => cidr.includes(\"/\") ? ipVersion(cidr) : 0;\n\n// TODO: pass parsed objects in here\nfunction compare(a, b) {\n  const {number: aNum, version: aVersion} = parseIp(a.replace(/\\/.+/, \"\"));\n  const {number: bNum, version: bVersion} = parseIp(b.replace(/\\/.+/, \"\"));\n  if (aVersion === bVersion) {\n    return aNum - bNum > 0n ? 1 : aNum - bNum < 0n ? -1 : 0;\n  } else {\n    return aVersion > bVersion;\n  }\n}\n\nfunction doNormalize(cidr, {compress = true, hexify = false} = {}) {\n  const {start, prefix, single, version} = parse(cidr);\n  if (!single) { // cidr\n    // set network address to first address\n    const ip = normalizeIp(stringifyIp({number: start, version}), {compress, hexify});\n    return `${ip}/${prefix}`;\n  } else { // single ip\n    return normalizeIp(cidr, {compress, hexify});\n  }\n}\n\nexport function normalize(cidr, {compress = true, hexify = false} = {}) {\n  if (Array.isArray(cidr)) {\n    return cidr.map(entry => normalize(entry, {compress, hexify}));\n  } else {\n    return doNormalize(cidr, {compress, hexify});\n  }\n}\n\nexport function parse(str) {\n  const cidrVer = cidrVersion(str);\n  const parsed = Object.create(null);\n\n  if (cidrVer) {\n    parsed.cidr = str;\n    parsed.version = cidrVer;\n  } else {\n    const version = ipVersion(str);\n    if (version) {\n      parsed.cidr = `${str}/${bits[version]}`;\n      parsed.version = version;\n    } else {\n      throw new Error(`Network is not a CIDR or IP: ${str}`);\n    }\n  }\n\n  const [ip, prefix] = parsed.cidr.split(\"/\");\n\n  if (!/^[0-9]+$/.test(prefix)) {\n    throw new Error(`Network is not a CIDR or IP: ${str}`);\n  }\n\n  parsed.prefix = prefix;\n  parsed.single = prefix === String(bits[parsed.version]);\n  const {number, version} = parseIp(ip);\n  const numBits = bits[version];\n  const ipBits = number.toString(2).padStart(numBits, \"0\");\n  const prefixLen = Number(numBits - prefix);\n  const startBits = ipBits.substring(0, numBits - prefixLen);\n  parsed.start = BigInt(`0b${startBits}${\"0\".repeat(prefixLen)}`);\n  parsed.end = BigInt(`0b${startBits}${\"1\".repeat(prefixLen)}`);\n  return parsed;\n}\n\n// returns whether networks fully or partially overlap\nfunction doNetsOverlap(a, b) {\n  //    aaa\n  // bbb\n  if (a.start > b.end) return false; // a starts after b\n\n  // aaa\n  //    bbb\n  if (b.start > a.end) return false; // b starts after a\n\n  return true;\n}\n\n// returns whether network a fully contains network b;\nfunction netContains(a, b) {\n  //  aaa\n  // bbbb\n  if (b.start < a.start) return false; // a starts after b\n\n  // aaa\n  // bbbb\n  if (b.end > a.end) return false; // b starts after a\n\n  return true;\n}\n\n// exclude b from a and return remainder cidrs\nfunction excludeNets(a, b, v) {\n  const parts = [];\n\n  // compareTo returns negative if left is less than right\n\n  //       aaa\n  //   bbb\n  //   aaa\n  //       bbb\n  if (a.start > b.end || a.end < b.start) {\n    return [a.cidr];\n  }\n\n  //   aaa\n  //   bbb\n  if (a.start === b.start && a.end === b.end) {\n    return [];\n  }\n\n  //   aa\n  //  bbbb\n  if (a.start > b.start && a.end < b.end) {\n    return [];\n  }\n\n  // aaaa\n  //   bbbb\n  // aaaa\n  //   bb\n  if (a.start < b.start && a.end <= b.end) {\n    parts.push({start: a.start, end: b.start - 1n});\n  }\n\n  //    aaa\n  //   bbb\n  //   aaaa\n  //   bbb\n  if (a.start >= b.start && a.end > b.end) {\n    parts.push({start: b.end + 1n, end: a.end});\n  }\n\n  //  aaaa\n  //   bb\n  if (a.start < b.start && a.end > b.end) {\n    parts.push(\n      {start: a.start, end: b.start - 1n},\n      {start: b.end + 1n, end: a.end},\n    );\n  }\n\n  const remaining = [];\n  for (const part of parts) {\n    for (const subpart of subparts(part)) {\n      remaining.push(formatPart(subpart, v));\n    }\n  }\n\n  return merge(remaining);\n}\n\nfunction biggestPowerOfTwo(num) {\n  if (num === 0n) return 0n;\n  return 2n ** BigInt(String(num.toString(2).length - 1));\n}\n\nfunction subparts(part) {\n  // special case for when part is length 1\n  if ((part.end - part.start) === 1n) {\n    if (part.end % 2n === 0n) {\n      return [{start: part.start, end: part.start}, {start: part.end, end: part.end}];\n    } else {\n      return [{start: part.start, end: part.end}];\n    }\n  }\n\n  const size = diff(part.end, part.start);\n  let biggest = biggestPowerOfTwo(size);\n\n  let start, end;\n  if (size === biggest && part.start + size === part.end) {\n    return [part];\n  } else if (part.start % biggest === 0n) {\n    // start is matching on the size-defined boundary - ex: 0-12, use 0-8\n    start = part.start;\n    end = start + biggest - 1n;\n  } else {\n    start = (part.end / biggest) * biggest;\n\n    // start is not matching on the size-defined boundary - 4-16, use 8-16\n    if ((start + biggest - 1n) > part.end) {\n      // divide will floor to nearest integer\n      start = ((part.end / biggest) - 1n) * biggest;\n\n      while (start < part.start) {\n        biggest /= 2n;\n        start = ((part.end / biggest) - 1n) * biggest;\n      }\n\n      end = start + biggest - 1n;\n    } else {\n      start = (part.end / biggest) * biggest;\n      end = start + biggest - 1n;\n    }\n  }\n\n  let parts = [{start, end}];\n\n  // additional subnets on left side\n  if (start !== part.start) {\n    parts = parts.concat(subparts({start: part.start, end: start - 1n}));\n  }\n\n  // additional subnets on right side\n  if (end !== part.end) {\n    parts = parts.concat(subparts({start: end + 1n, end: part.end}));\n  }\n\n  return parts;\n}\n\nfunction diff(a, b) {\n  if (typeof a !== \"bigint\") a = BigInt(a);\n  if (typeof b !== \"bigint\") b = BigInt(b);\n  a += 1n;\n  return a - b;\n}\n\nfunction formatPart(part, version) {\n  const ip = normalize(stringifyIp({number: BigInt(part.start.toString()), version}));\n  const zeroes = diff(part.end, part.start).toString(2);\n  const prefix = bits[version] - (zeroes.match(/0/g) || []).length;\n  return `${ip}/${prefix}`;\n}\n\nfunction mapNets(nets) {\n  const maps = {4: {}, 6: {}}; // TODO: use Map with BigInt key\n  for (const {start, end, version} of nets) {\n    if (!maps[version][start]) maps[version][start] = {};\n    if (!maps[version][end]) maps[version][end] = {};\n\n    if (maps[version][start].start) {\n      maps[version][start].start += 1;\n    } else {\n      maps[version][start].start = 1;\n    }\n\n    if (maps[version][end].end) {\n      maps[version][end].end += 1;\n    } else {\n      maps[version][end].end = 1;\n    }\n  }\n  return maps;\n}\n\nfunction doMerge(maps, v) {\n  let start = null;\n  let end = null;\n  const numbers = Object.keys(maps);\n  let depth = 0;\n  const merged = [];\n\n  for (const [index, number] of numbers.entries()) {\n    const marker = maps[number];\n\n    if (start === null && marker.start) {\n      start = BigInt(number);\n    }\n    if (marker.end) {\n      end = BigInt(number);\n    }\n\n    if (marker.start) depth += marker.start;\n    if (marker.end) depth -= marker.end;\n\n    const next = numbers[index + 1];\n    if (marker.end && depth === 0 && next && ((BigInt(next) - BigInt(number)) > 1)) {\n      // when there is a end and the next part is more than one number away, we cut a part\n      for (const sub of subparts({start, end})) {\n        merged.push(formatPart(sub, v));\n      }\n      start = null;\n      end = null;\n    } else if (index === (numbers.length - 1)) {\n      // cut the final part\n      for (const sub of subparts({start, end})) {\n        merged.push(formatPart(sub, v));\n      }\n    }\n  }\n  return merged;\n}\n\nexport function merge(nets) {\n  // sort to workaround https://github.com/silverwind/cidr-tools/issues/17\n  nets = uniq((Array.isArray(nets) ? nets : [nets]).sort(compare).map(parse));\n  const maps = mapNets(nets);\n\n  const merged = {4: [], 6: []};\n  for (const v of [4, 6]) {\n    merged[v] = doMerge(maps[v], v);\n  }\n\n  return [...merged[4].sort(compare), ...merged[6].sort(compare)];\n}\n\nexport function exclude(basenets, exclnets) {\n  basenets = uniq(Array.isArray(basenets) ? basenets : [basenets]);\n  exclnets = uniq(Array.isArray(exclnets) ? exclnets : [exclnets]);\n\n  basenets = merge(basenets);\n  exclnets = merge(exclnets);\n\n  const bases = {4: [], 6: []};\n  const excls = {4: [], 6: []};\n\n  for (const basenet of basenets) {\n    bases[cidrVersion(basenet)].push(basenet);\n  }\n\n  for (const exclnet of exclnets) {\n    excls[cidrVersion(exclnet)].push(exclnet);\n  }\n\n  for (const v of [4, 6]) {\n    for (const exclcidr of excls[v]) {\n      for (const [index, basecidr] of bases[v].entries()) {\n        const base = parse(basecidr);\n        const excl = parse(exclcidr);\n        const remainders = excludeNets(base, excl, v);\n        if (base.cidr !== remainders.toString()) {\n          bases[v] = bases[v].concat(remainders);\n          bases[v].splice(index, 1);\n        }\n      }\n    }\n  }\n\n  return bases[4].concat(bases[6]).sort(compare);\n}\n\nexport function expand(nets) {\n  nets = uniq(Array.isArray(nets) ? nets : [nets]);\n\n  const ips = [];\n  for (const net of merge(nets)) {\n    const {start, end, version} = parse(net);\n    for (let number = start; number <= end; number++) {\n      ips.push(stringifyIp({number, version}));\n    }\n  }\n  return ips.map(normalize);\n}\n\nexport function overlap(a, b) {\n  const aNets = uniq(Array.isArray(a) ? a : [a]);\n  const bNets = uniq(Array.isArray(b) ? b : [b]);\n\n  for (const a of aNets) {\n    const aParsed = parse(a);\n    for (const b of bNets) {\n      const bParsed = parse(b);\n\n      // version mismatch\n      if (aParsed.version !== bParsed.version) {\n        continue;\n      }\n\n      if (doNetsOverlap(aParsed, bParsed)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function contains(a, b) {\n  const aNets = uniq(Array.isArray(a) ? a : [a]);\n  const bNets = uniq(Array.isArray(b) ? b : [b]);\n\n  const numExpected = bNets.length;\n  let numFound = 0;\n  for (const a of aNets) {\n    const aParsed = parse(a);\n    for (const b of bNets) {\n      const bParsed = parse(b);\n\n      // version mismatch\n      if (aParsed.version !== bParsed.version) {\n        continue;\n      }\n\n      if (netContains(aParsed, bParsed)) {\n        numFound++;\n        continue;\n      }\n    }\n  }\n\n  return numFound === numExpected;\n}\n\nexport default {\n  merge,\n  exclude,\n  expand,\n  overlap,\n  contains,\n  normalize,\n  parse,\n};\n"],"names":["ipVersion","ip","parseIp","version","number","exp","res","n","part","a","b","c","d","str","scopeid","parts","index","bits","cidrVersion","cidr","parse","cidrVer","parsed","prefix","numBits","ipBits","prefixLen","startBits"],"mappings":"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","x_google_ignoreList":[0,1]}